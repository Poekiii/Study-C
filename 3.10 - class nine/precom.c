
/*-------------------预处理----------------------*/
// text.c  -->  编译(.obj) + 链接     text.exe    --> 运行
// 源文件(源程序)                     可执行程序
// |               翻译环境               |    运行环境
// |    编译(编译器)      |   链接(链接器) |
// | 预编译 | 编译 | 汇编 |

// 1.翻译环境，在这个环境中源代码被转换为可执行的机器指令(二进制代码)。
// 2.执行环境，它用于实际执行代码。.exe是二进制文件.

// 编译:每一个源文件都会单独到编译器进行处理 生成对应自己的目标文件(.obj)
// 链接:每一个目标文件通过链接器 链接成可执行程序;链接器会引入标准C函数库中任何被该程序所用到的函数(链接库),以及程序员的个人的程序库
//.LIB(静态库libraries)
//extern 外部函数声明

// 一、 编译的过程 (预编译 编译 汇编)
// 1. 预处理 选项 gcc -E test.c -o test.i 预处理完成之后就停下来，预处理之后产生的结果都放在test.i文件中
    // ①#include 头文件的包含
    // ②删除注释 '//...' '/*...*/' ;使用空格来替换
    // ③处理预处理指令  #define 
    // 总结:都是文本操作！

// 2. 编译 选项 gcc -S test.c 编译完成之后就停下来，结果保存在test.s中
    // 总:把 c语言代码 翻译成 汇编代码
    // 分: 1.语法分析;(根据编译原理 利用语法树的结构等等) 
    //     2.词法分析;
    //     3.语义分析;
    //     4.符号汇总;

// 3. 汇编 gcc -c test.c 汇编完成之后就停下来，结果保存在test.o中
    // 总:把 汇编代码 转换成 二进制代码
    // 分:形成符号表(对所有的符号进行汇总 并且记录地址) Add 0x100 | main 0x200 ...

// 二、 链接的过程 (合并段表 符号表的合并和重定位)
// 把所有的.o目标文件链接
// 1.合并段表(elf格式)
//     .o文件固定把自己分成几个段 链接时 会把对应的段进行合并(根据自己的规则)
// 2.符号表的合并和重点位
//     把符号表的内容进行合并 当冲突时候 用有效的地址 

// #include <stdio.h>
// extern int Add(int x, int y); //Add表示一个符号 地址是0x00 因为这个是无效的
// int main()//main也是一个符号 地址有效
// {
//     int a = 10;
//     int b = 20;
//     int c = Add(a, b);
//     printf("%d\n", c);
//     return 0;
// }
