#include <stdio.h>

//题目1
// int main()
// {
//     int a[5] = { 1, 2, 3, 4, 5 };
//     int *ptr = (int *)(&a + 1); //&a表示a数组的地址 &a+1表示跨越数组a后的地址
//     printf( "%d,%d", *(a + 1), *(ptr - 1));//a+1表示第二个元素的地址 *(a+1)表示第二个元素 *(ptr - 1)表示a的最后一个元素
//     //2 5
//     return 0;
// }

//题目2
//由于还没学习结构体，这里告知结构体的大小是20个字节
// struct Test
// {
//     int Num;
//     char *pcName;
//     short sDate;
//     char cha[2];
//     short sBa[4];
// }* p;//

// //假设p 的值为0x100000。 如下表表达式的值分别为多少？
// int main()
// {
//     //%p输出地址 都是16进制的
//     p = (struct Test *)0x100000;//把结构体的地址放到指针p中
//     printf("%p\n", p + 0x1);//0x00100014 0x1 = 1  p+1 - 就是越过结构体(20个字节)后的地址 20d=14h
//     printf("%p\n", (unsigned long)p + 0x1);//0x00100001 unsigned long 其实是转化为整型 即0x00100000转化为10进制+1 再转化为16进制    
//     printf("%p\n", (unsigned int*)p + 0x1);//0x00100004 unsigned int* 指针 其实大小是4字节 所以+0x1 就是为+4 取决于指针类型
//     //指针+-整数的值 取决于指针类型
//     return 0;
// }


//题目3
// int main()
// {
//     //每个地址间距是1字节 int存储是 4字节 一个(32位) 则如下
//     //                            首地址(差4字节)2地址                               &a+1的地址     
//     //本电脑是小段存储  a(0x00000000) |10 00 00 00|02 00 00 00|03 00 00 00 | 04 00 00 00|
//     //                                int(a)+1  则往后输出4字节(16进制) 00 00 00 02 又因为小端 实际输出0x20 00 00         
//     //假设a地址是0x00000000
//     //%x是输出一个16进制数
//     int a[4] = { 1, 2, 3, 4 };
//     int *ptr1 = (int *)(&a + 1);//a为数组地址 &a+1为跨越a数组的地址
//     int *ptr2 = (int *)((int)a + 1);//a是首地址 (int)a+1 - 为首地址+1字节
//     printf( "%x,%x", ptr1[-1], *ptr2);//ptr1为跨越a数组的地址 ptr1[-1] = *(ptr-1) 则为第四个元素的地址
//     return 0;
// }

//题目4
// int main()
// {
//     int a[3][2] = { (0, 1), (2, 3), (4, 5) };//(a,b)并不是想的第一行元素组的两个元素 而是靠的逗号表达式
//     //逗号运算符确保操作数被顺序地处理：先计算左边的操作数，再计算右边的操作数。右操作数的类型和值作为整个表达式的结果
//     //所以实际上a的数组存的是
//     // 1  3  a[0]
//     // 5  0  a[1]
//     // 0  0  a[2]
//  //a[i][0] a[i][1]

//     int *p; 
//     p = a[0];//a[0]第一行的地址
//     printf( "%d\n", p[0]); //*(p+0) = p[0] - 则为第一行第一个元素 最终结果为1
//     return 0;
// }

//题目5
// int main()
// {
//     //0 0 0 0 0
//     //0 0 0 0 0
//     //0 0 0 p 0
//     //0 0 a 0 0
//     //&p[4][2] = *(*(p+4)+2)
//     int a[5][5];//a的指针类型是 int(*)[5]
//     int(*p)[4];//p的指针类型是 int(*)[4]
//     p = a;//会报警告 但有结果
//     printf( "%p,%d\n", &p[4][2] - &a[4][2], &p[4][2] - &a[4][2]);//p[4][2] 其实是第5行的第三个元素
//     //p42会落后a42 4个字节即 为-4
//     //但是%p打印的是补码的值 因为他认为都是无符号数 -4的补码为fffffffc
//     return 0;
// }

//题目6
// int main()
// {
//     //aa
//     //1 2 3 4 5
//     //6 7 8 9 10
//     //指针+-整数的值 取决于指针类型
//     // int arr[10]={}; int* p=arr; *(p+2) == p[2] == *(arr+2) == arr[2]
//     // 并且编译器会从a[2]-->*(a+2)来定位
//     int aa[2][5] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
//     int *ptr1 = (int *)(&aa + 1);//跳过aa二维数组后的地址 需要指出的是aa的指针类型是int(*)[2] 所以需要强制类型转化
//     int *ptr2 = (int *)(*(aa + 1));//等价于aa[1] - 第二行首元素地址 此处注意(int*)的强制转化多余
//     printf( "%d,%d", *(ptr1 - 1), *(ptr2 - 1));//前移动一个指针 则结果为10 5
//     return 0;
// }

//题目7
// int main()
// {
//     //char* p = "abcd"  是指常量字符串"abcd"的首地址赋给指针p
//     char *a[] = {"work","at","alibaba"};//char* []  字符指针数组 a[0]指向w a[1]指向a ...
//     char **pa = a;//a是指针数组名 表示首指针的地址  *pa 表示它是指针,char* 表示他指向的对象类型  
//     pa++;//pa+1 跳过的就是一个char*  此时指向的是a[1]这个指针的地址
//     printf("%s\n", *pa);//对于pa的解引用 其实就是a[1]的地址 最终它指向的就是"at"
//     return 0;
// }

//题目8
int main()
{
    //cpp --> cp[0] \ /c[0] "ENTER" 的首地址
    //        cp[1] \/c[1] "NEW"
    //        cp[2] // c[2] "POINT"
    //        cp[3]/   \ —c[3] "FIRST"

    char *c[] = {"ENTER","NEW","POINT","FIRST"};
    char**cp[] = {c+3,c+2,c+1,c};
    char***cpp = cp;
    printf("%s\n", **++cpp);//cpp+1其实指向的是cp[1]的地址 再解解引用为
    printf("%s\n", *--*++cpp+3);//cpp再+1(前面加过一次了) 此时++cpp已经指向cp[2] 进而指向c[1] 又因为-- 所以最终指向c[0] "ENTER"
    //再+3 指针类型为char 就向右边移动3个字节此时指向E 最终输出"ER"
    printf("%s\n", *cpp[-2]+3);//cpp[-2]=*(cpp-2) cpp已经指向cp[2]了 再-2 指向了cp[0]-->c[3] 解引用为 "FIRST"
    //再+3 此时指向S前 所以最终输出ST  注意！！cpp依然还是指向cp[2]
    printf("%s\n", cpp[-1][-1]+1);//cpp[-1][-1] = *(*(cpp-1)-1) 此时的cpp依然指向cp[2] 与前面分析相同 答案是"EW"
    return 0;
}


