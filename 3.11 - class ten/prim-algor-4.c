/*-------------------数组类----------------------*/
// 题目1 - 数组中数字出现的次数
// 一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。
// 示例 1：
// 输入：nums = [4,1,4,6]
// 输出：[1,6] 或 [6,1]

/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
//异或的性质
//a^0=a;
//a^a=0;
//a^b^b = a^0 = a;
//a^b=c  --> c^b=a;
//lowbit
//找到最低位的1 即4 = 100  那么最低位的1 在第三位 那么返回得出100; 例如20 = 10100 那么最低位的1也在第三位 也返回1; 
//再例如3 = 011 最低位在1 则返回1;
// int* singleNumbers(int* nums, int numsSize, int* returnSize){
//     int *ret  = (int *)malloc(2*sizeof(int));
//     int tmp = 0; 
//     *returnSize = 2;
//     if (nums == NULL) return 0;
//     for (int i = 0; i < numsSize; i ++)
//     {
//         tmp ^= nums[i]; //所有值进行异或 得到最终相同的抵消 剩下的结果是答案a和b的异或值 这里放到tmp中
//     }
//     //tmp其实表示a 与 b 在对应二进制位上 是否相同 相同为0 不同为1;
//     int flag = (tmp)&(-tmp);
//     //利用计算机的存储性质 得到最低位的1 
//     //等效于 
//     // while ((tmp&1) ==0)
//     // {
//     //     index +=1;
//     //     tmp >>=1;
//     // }
//     //也等价于 tmp ^ (tmp - 1) & tmp  根据优先级&会在^前计算
//     int x = 0;
//     int y = 0;
//     for(int j = 0; j <numsSize; j++)
//     {
//         if((flag&nums[j]) != 0 ) x ^= nums[j];//!= 和 == 的优先级都高于 & 所以需要加括号
//         //因为以及找到不同的那一位 flag = 100 假设a=100100 b=11011 a和b与flag 根据对应位与的规则 flag&a=100 flag&b=0 则可以区分出a和b
//         //至于其他的数分到哪个组我们并不关心 因为可以通过再一次遍历与的方式 把相同的数消掉 最终我们找到a 
//     }
//     y = x ^ tmp;//利用a^b=c  --> c^b=a; 找到另外一个数字b
//     ret[0] = x;
//     ret[1] = y;
//     return ret;
// }

//题目2 - 数组中数字出现的次数Ⅱ
// 在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。
// 示例 1：
// 输入：nums = [3,4,3,3]
// 输出：4

// 方法 1 - 遍历统计
// 思路：考虑数字的二进制形式，对于出现三次的数字，各 二进制位 出现的次数都是 3 的倍数。
// 因此，统计所有数字的各二进制位中 1 的出现次数，并对 3 求余，结果则为只出现一次的数字。
// 例如 [3, 5, 3, 3]
//                 3 = 0 0 1 1
//                 5 = 0 1 0 1
//                 3 = 0 0 1 1
//                 3 = 0 0 1 1
// 总(对应位1的个数)  = 0 1 3 4
// 然后对应1的总数%3  = 0 1 0 1 = 5 (答案)
// #include <math.h>
// int singleNumber(int* nums, int numsSize){
//     int tmp[32] = {0}; 
//     int ret = 0;
//     //1.计算对应位上面1的个数
//     for (int i = 0; i < numsSize; i++)  //计算所有值在0-32位上面 1 的个数
//     {
//         for (int j = 0; j < 32; j++)
//         {
//             tmp[j] += nums[i] & 1; //若nums[i]的j位为1 那么与的结果也为1 
//             nums[i] >>= 1;//计算完最后一位后 右移动 计算j+1位的1个数; 此为无符号的右移动 多出来的位补零
//         }
//     }
//     //2.把个数对3求余 滤出出现3次的数字带来的影响 得到单数的影响值
//     for (int i = 0; i < 32; i++)
//     {
//         tmp[i] = tmp[i] % 3; //对应位上1的个数 并且放到tmp数组里面
//     }
//     //3.还原
//     for (int i = 0; i < 32; i++)
//     {
//         ret <<= 1; // 左移 1 位
//         ret |= tmp[31 - i]; // 恢复第 i 位的值到 ret
//     }
//     return ret;
// }


//方法2 - 有限状态自动机
// 各二进制位的 位运算规则相同 ，因此只需考虑一位即可。如下图所示，对于所有数字中的某二进制位 1 的个数，存在 3 种状态，即对 3 余数为 0, 1, 2 。
// 若输入二进制位 1 ，则状态按照以下顺序转换；
// 若输入二进制位 0 ，则状态不变。
/*  
            ab    ab    ab    ab
    状态机: 00 -> 01 -> 10 -> 00
    真值表:
    c   b   a   b'
    0   0   1   0
    0   0   0   0
    0   1   1   0
    0   1   0   1
    1   0   1   0
    1   0   0   1
    1   1   1   0
    1   1   0   0
    取结果为1的情况：b' = ~ab~c + ~a~bc = ~a(b~c+~bc) = ~a(b^c)
    因此，可以推出: b = b ^ c & ~a

    在更新b之后：
            ab    ab    ab    ab
    状态机: 01 -> 00 -> 10 -> 01
    调换ab: ba    ba    ba    ba
    状态机: 10 -> 00 -> 01 -> 10
    与上述一致，因此，可以推出：a = a ^ c & ~b

*/
// int singleNumber(int* nums, int numsSize){
//     int one = 0;
//     int two = 0;
//     for(int i = 0; i < numsSize; i++)
//     {
//         one = (one ^ nums[i]) & ~two;
//         two = (two ^ nums[i]) & ~one;
//     }
//     return one;
// }