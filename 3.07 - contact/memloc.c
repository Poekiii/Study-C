#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
/*-------------------动态内存分配----------------------*/
// 为什么存在动态内存分配
// 我们已经掌握的内存开辟方式有：
// int val = 20;//在栈空间上开辟四个字节
// char arr[10] = {0};//在栈空间上开辟10个字节的连续空间
// 但是上述的开辟空间的方式有两个特点：
// 1. 空间开辟大小是固定的。
// 2. 数组在申明的时候，必须指定数组的长度，它所需要的内存在编译时分配。
// 但是对于空间的需求，不仅仅是上述的情况。有时候我们需要的空间大小在程序运行的时候才能知道，那数组的编
// 译时开辟空间的方式就不能满足了。 这时候就只能试试动态存开辟了。

// 1.malloc(动态分配) 和 free(内存释放)

// void* malloc (size_t size)
// 这个函数向内存申请一块连续可用的空间，并返回指向这块空间的指针。
// 如果开辟成功，则返回一个指向开辟好空间的指针。
// 如果开辟失败，则返回一个NULL指针，因此malloc的返回值一定要做检查。
// 返回值的类型是 void* ，所以malloc函数并不知道开辟空间的类型，具体在使用的时候使用者自己来决定。
// 如果参数 size 为0，malloc的行为是标准是未定义的，取决于编译器。

// void free (void* ptr);
// free函数用来释放动态开辟的内存
// 如果参数 ptr 指向的空间不是动态开辟的，那free函数的行为是未定义的。
// 如果参数 ptr 是NULL指针，则函数什么事都不做。
// malloc和free都声明在 stdlib.h 头文件中。

// int main()
// {
//     //向内存申请10个整型的空间
//     int *p = (int *)malloc(10 * sizeof(int)); //若返回NULL时 说明没有足够可用了 所以每次使用都要检查
//     if(p == NULL)
//     {
//         //打印申请错误的原因
//         printf("%s\n", strerror(errno));
//     }
//     else
//     {
//         //正常使用空间
//         int i;
//         for (i = 0; i < 10; i++)
//         {
//             *(p + i) = i;
//         }
//         for (i = 0; i < 10; i++)
//         {
//             printf("%d ",*(p + i));
//         }
//     }
//     //当动态申请空间的空间不再使用
//     //释放空间  PS:但是当程序的生命周期结束时 系统也会自动回收这些空间
//     free(p); 
//     p = NULL; //由于原地址由p指针维护 虽然它的内存空间已经释放 但是p依然指向该地址
//     //为了防止出错(不小心有某个程序调用) 就把p的指向NULL  
//     return 0;
// }

// 2.calloc (数组块的内存分配函数)
// void * calloc(size_t num,size_t size)
// 函数的功能是为 num 个大小为 size 的元素开辟一块空间，并且把空间的每个字节初始化为0。
// 与函数 malloc 的区别只在于 calloc 会在返回地址之前把申请的空间的每个字节初始化为全0。

// int main()
// {
//     //malloc(10*sizeof(int)) - malloc的写法 [不初始化,但是效率高]
//     int *p = (int *)calloc(10, sizeof(int));//开辟10个整型空间 并且初始化0  [初始化,但是效率稍低]
//     free(p);//free函数是用来释放动态开辟空间的
//     p = NULL;
//     return 0;
// }

// 3.realloc (重新开辟空间)
// void* realloc (void* ptr, size_t size);
// ptr 是要调整的内存地址
// size 调整之后新大小
// 返回值为调整之后的内存起始位置。
// 这个函数调整原内存空间大小的基础上，还会将原来内存中的数据移动到新的空间。

// realloc函数的出现让动态内存管理更加灵活。
// 有时会我们发现过去申请的空间太小了，有时候我们又会觉得申请的空间过大了，那为了合理的时候内存，
// 我们一定会对内存的大小做灵活的调整。那 realloc 函数就可以做到对动态开辟内存大小的调整。

int main()
{
    int *p1 = (int *)malloc(10 * sizeof(int));
    //malloc 开辟10个int内存
    //目前觉得不够了 所以想再开辟 10个int (所以填20*int)
    //realloc再开辟
    int *p2 = realloc(p1, 20 * sizeof(int));
    // 1.如果p1指向的空间之后有足够的空间 那么返回p1
    // 2.如果p1之后没有足够空间 那么将开辟满足条件的新空间 并且把原来的内存中的数据拷贝过来
    // 释放旧的内存空间 返回新地址
    // 所以一般不把值直接返回给原来p1指针 因为若新开辟失败 返回NULL给p1 使得原来的地址都找不到了
    // 但是可以用一个新p2的来接收
    if(p2!=NULL) //追加成功再转移
    {
        p1 = p2;
    }
    //用完释放内存
    free(p1);
    p1 = NULL;
}

// 4.常见的动态内存错误
// ①对NULL指针的解引用操作
// void test()
// {
//     int *p = (int *)malloc(INT_MAX/4);
//     *p = 20;//如果p的值是NULL，就会有问题
//     free(p);
// }

// ②对动态开辟空间的越界访问
// void test()
// {
//     int i = 0;
//     int *p = (int *)malloc(10*sizeof(int));
//     if(NULL == p)
//     {
//     exit(EXIT_FAILURE);
//     }
//     for(i=0; i<=10; i++)
//     {
//     *(p+i) = i;//当i是10的时候越界访问
//     }
//     free(p);
// }

// ③对非动态开辟内存使用free释放
// void test()
// {
//     int a = 10;
//     int *p = &a;
//     free(p);//ok?
// }

// ④使用free释放一块动态开辟内存的一部分
// void test()
// {
//     int *p = (int *)malloc(100);
//     p++;
//     free(p);//p不再指向动态内存的起始位置
// }

// ⑤对同一块动态内存多次释放
// void test()
// {
//  int *p = (int *)malloc(100);
//  free(p);
//  free(p);//重复释放
// }

// ⑥动态开辟内存忘记释放(内存泄漏)
// void test()
// {
//     int *p = (int *)malloc(100);
//     if(NULL != p)
//     {
//          *p = 20;
//     }
// }
// int main()
// {
//     test();
//     while(1);
// }
// NOTICE:忘记释放不再使用的动态开辟的空间会造成内存泄漏。 切记： 动态开辟的空间一定要释放，并且正确释放 。


